#include<iostream>

using namespace std;

int N, M, K;  // N: a의 개수, M: z의 개수, K: K번째 사전순 조합
long D[202][202];  // 이항 계수 저장 배열 (최대 N+M이 200까지 가능하므로 D[202][202] 배열 선언)

int main()
{
	cin >> N >> M >> K;

	// 이항 계수 구하기
	for (int i = 0; i <= 200; i++)
	{
		for (int j = 0; j <= i; j++)
		{
			if (j == 0 || j == i)  // 첫 번째 또는 마지막 값은 항상 1
			{
				D[i][j] = 1;
			}
			else
			{
				// 이항 계수 점화식: C(i, j) = C(i-1, j-1) + C(i-1, j)
				D[i][j] = D[i - 1][j - 1] + D[i - 1][j];

				// 값이 1,000,000,001 이상이면 오버플로우 방지하고 1,000,000,001로 처리
				if (D[i][j] > 1000000000)
				{
					D[i][j] = 1000000001;
				}
			}
		}
	}

	// 주어진 K가 가능한 범위 내에 있는지 체크 (즉, N + M개 중에서 M개를 고르는 조합 수가 K보다 작으면 -1 출력)
	if (D[N + M][M] < K)
	{
		cout << "-1";  // 불가능한 경우
	}
	else
	{
		// 사전순으로 K번째 문자열을 구하기
		while (false == (N == 0 && M == 0))  // N과 M이 모두 0이 될 때까지 반복
		{
			// "a"를 선택한 경우
			if (D[N - 1 + M][M] >= K)  // "a"를 선택할 경우 나머지 조합 수가 K보다 크거나 같으면 "a" 선택
			{
				cout << "a";
				N--;  // "a"를 하나 선택했으므로 N을 1 감소
			}
			else  // "a"를 선택할 수 없으면 "z"를 선택
			{
				cout << "z";
				K = K - D[N - 1 + M][M];  // K번째 값에서 "a"를 고른 경우의 조합 수만큼 빼줌
				M--;  // "z"를 하나 선택했으므로 M을 1 감소
			}
		}
	}
}